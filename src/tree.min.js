class Tree{#e=new Map;constructor(e=2){if(e<1)throw new Error("Invalid degree");this.degree=e,this.root=null}addRoot(e){if(null!==this.root)throw new Error("Tree must have only one root element!");this.#e.set(e,new Set),this.root=e}add(e,t){if(!this.#e.has(t))throw new Error("Invalid parent!");if(this.#e.has(e))throw new Error("Object already exists!");if(this.#e.get(t).size>=this.degree)throw new Error(`Cannot add more than ${this.degree} children to a node.`);this.#e.set(e,new Set),this.#e.get(t).add(e)}addChildren(e,t=[]){for(let s of t)this.add(s,e)}get length(){return this.#e.size}get isEmpty(){return 0===this.#e.size}has(e){return this.#e.has(e)}hasChildren(e){return this.#e.has(e)&&this.#e.get(e).size>0}getChildren(e){return this.#e.has(e)?[...this.#e.get(e)]:[]}values(){return Array.from(this.#e.values())}printType(){switch(this.degree){case 1:return"Unitary";case 2:return"Binary";case 3:return"Ternary";default:return`${this.degree}. degree`}}display(){let e="";for(let t of this.#e.keys()){let s=this.#e.get(t);e+=`\n ${t}${this.hasChildren(t)?` => ${[...s].join(", ")}`:""}`}console.log(`[${this.printType()}] Tree (${this.#e.size}) {\n ${this.root} [root] ${e}\n}`)}}
