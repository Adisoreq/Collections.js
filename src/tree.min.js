class Tree{#e=new Map;constructor(e=2){if(e<1)throw new Error("Invalid degree");this.degree=e,this.root=null}addRoot(e){if(null!==this.root)throw new Error("Tree must have only one root element!");this.#e.set(e,new Set),this.root=e}add(e,t){if(!this.#e.has(t))throw new Error("Invalid parent!");if(this.#e.has(e))throw new Error("Object already exists!");if(this.#e.get(t).size>=this.degree)throw new Error(`Cannot add more than ${this.degree} children to a node.`);this.#e.set(e,new Set),this.#e.get(t).add(e)}addChildren(e,t=[]){for(let r of t)this.add(r,e)}clear(){this.#e.clear()}get length(){return this.#e.size}get isEmpty(){return 0===this.#e.size}contains(e){return this.#e.has(e)}hasChildren(e){return this.#e.has(e)&&this.#e.get(e).size>0}getChildren(e){return this.#e.has(e)?[...this.#e.get(e)]:[]}values(){return Array.from(this.#e.values())}printType(){switch(this.degree){case 2:return"Binary";case 3:return"Ternary";case 4:return"Quaternary";default:return`${this.degree}. degree`}}display(){let e="";for(let t of this.#e.keys()){let r=this.#e.get(t);e+=`\n ${t}${this.hasChildren(t)?` => ${[...r].join(", ")}`:""}`}console.log(`[${this.printType()}] Tree (${this.#e.size}) {\n ${this.root} [root] ${e}\n}`)}}